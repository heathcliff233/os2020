# L1 实验报告

<div style="text-align: right"> 匡亚明学院 洪亮 181240019 </div>
L1杀我。。。

窝觉得可以好好谈谈这323traces是怎么搞出来的

### 优化

如您所见，L1有三个分支，对应我的三个版本

* 版本一（过一个hard）
  - 思路：按16k页分配到cpu，所有分配请求混在一起放在页上，每次对齐。free对指定内存块置位，页中全部被置位则页被回收。
  - 问题：若是频繁页分配，由于需要对齐（带有header在开头）16k中实际只能分配一个4k，浪费过大。由于大小不等，空洞过多。free太蠢了不说了。
* 版本二（碰巧能过两个hard）
  - 思路：按8192+512B为一页，处理4k分配更经济。页头加计数器，free使计数器归零后回收页。后续改进有累积多个页一次性释放。
  - 问题：你妈的瞎用锁吧就。依旧，内存空洞太多。
* 版本三（能过二～三个hard）
  - 思路：重写！分为12种大小进行内存分配，使用bitmap指示对应位置是否占有。遍历页寻找可用内存块（限制最大深度）。
  - 问题：遍历页太耗时。
* 版本三refined（ac）
  - 思路：每个cpu下12种分配每种都拆分为32个链表，分配时随机选择一个链表进行遍历。使用页锁。

### Debug

* intptr_t 和 uintptr_t 混用了
* 自己设计的测试用例有并发bug。。。吐了
* 页内计数器没用锁保护



# L2  实验报告

### 绝妙的设计（误

说起让线程在cpu间轮流转有点难，那只要改一改cpu的名字就可以实现cpu在线程间轮流转啦！

### Debug

* 印象最深刻的！！！pmm->alloc实现出来最多只支持4096分配，而把stack放进task结构体的话，task结构体大小必然超过限制！！！最后解决方案是把stack和task结构体分别分配
* os->init 中 trap->init 调用迟了导致没有初始化产生问题
* kmt_context_save中保存stack时误用指针类型转换导致不停的初始化